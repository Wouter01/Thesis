\chapter*{Abstract}
\chaptermark{Abstract}
\addcontentsline{toc}{chapter}{Abstract}  

Updating software of \acrfull{IoT} devices is currently difficult. Having a longer lifespan than the average gadget, and oftentimes having special hardware and compilers that requires a lot of maintenance, most \acrshort{IoT} devices lose software support too soon \cite{wasi_iot}.
\acrfull{Wasm}, once made to run compiled code in a lightweight virtual machine in the browser, is trying to tackle this problem by expanding its support outside the browser. Because of its near-native performance, security, compactness and language interoperability, \acrshort{Wasm} is gaining popularity for its use on edge devices \cite{wasi_iot}. However, \acrshort{Wasm} lacks a proper interface to use outside the browser. To tackle this issue the \acrfull{WASI} was introduced, with the goal to provide a universal \acrshort{API} for all supported platforms and languages. \acrshort{WASI} is still in development and currently lacks an \acrshort{API} for using USB devices. The goal of this thesis is to research and develop an \acrshort{USB} \acrshort{API} for \acrshort{WASI}.

As part of the development is creating a proposal to extend the standard, where the interface of the \acrshort{API} is laid out and other matter, such as platform support, is further discussed. As part of this thesis, an initial proposal has been created \cite{wasi_usb}. The proposal has advanced to Phase 1 of the proposal process \cite{proposal_phases} and progress is being made to progress to Phase 2. The proposal contains a \acrshort{WIT} interface which supports enumerating devices, reading descriptors, connecting, reading and writing to devices and getting device connection updates. After doing research on existing similar solutions, such as WebUSB \cite{WebUSB} and \cite{LibUSB}, the proposal has taken inspiration from LibUSB. This makes it easier for developers to port existing applications to \acrshort{Wasm} as both LibUSB and \acrshort{WASI} \acrshort{USB} have similar interfaces. Some parts have been made different deliberately, for example the way file handles work. This way, the \acrshort{API} is easier to reason about. As \acrshort{Wasm} is sandboxed by default, access control is provided so programs do not have access to all devices by default. It is up to the user to specify which devices a program can access.

A reference implementation for the \acrshort{API} is provided \cite{wasi_usb} and extends the Wasmtime \cite{wasmtime_website} runtime to provide support for the \acrshort{USB} \acrshort{API}.

The implementation has been evaluated in three ways. First, a functional evaluation was made, testing the functionality of the API. In this evaluation, a guest module will observe connection events for a specific game controller, connect to the game controller, read out its state and control its rumble motors, confirming that the most important parts of the \acrshort{API} work.

Afterwards, the implementation has been evaluated for latency and memory usage. This is done by creating a \acrshort{USB} mass storage device driver by using the \acrshort{WASI} \acrshort{USB} \acrshort{API}. The file tree of a \acrshort{USB} drive can be read out and the file contents can be read. Comparing this against a native implementation shows on average a 4.2\% increase in latency, which is a good result. Memory usage using the \acrshort{WASI} \acrshort{API} is significantly higher, with the program using approx. 70\% more memory during heavy workloads, compared to native. This is likely caused by the way the memory model works in the Component Model, requiring the use of copying of data between components.

The \acrshort{WASI} \acrshort{USB} \acrshort{API} still has a long way to go before it is production ready, but the example programs in this thesis show the possibilities of the \acrshort{API} and demonstrate how the \acrshort{API} can be used in real-world use cases.