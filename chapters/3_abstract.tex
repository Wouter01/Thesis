\chapter*{Abstract}
\chaptermark{Abstract}
\addcontentsline{toc}{chapter}{Abstract}  

Updating software of \acrfull{IoT} devices is currently difficult. Having a longer lifespan than the average gadget, and oftentimes having special hardware and compilers that requires a lot of maintenance, most \acrshort{IoT} devices lose software support too soon \cite{wasi_iot}.
\acrfull{Wasm}, once made to run compiled code in a lightweight virtual machine in the browser, is trying to tackle this problem by expanding its support outside the browser. Because of its near-native performance, security, compactness and language interoperability, \acrshort{Wasm} is gaining popularity for its use on edge devices \cite{wasi_iot}. However, \acrshort{Wasm} lacks a proper interface to use outside the browser. To tackle this issue the \acrfull{WASI} was introduced, with the goal to provide a universal \acrshort{API} for all supported platforms and languages. \acrshort{WASI} is still in development and currently lacks an \acrshort{API} for using USB devices. The goal of this thesis is to research and develop an \acrshort{USB} \acrshort{API} for \acrshort{WASI}.

As part of the development is creating a proposal to extend the standard, where the interface of the \acrshort{API} is laid out and other matter, such as platform support, is further discussed. As part of this thesis, an initial proposal has been created \cite{wasi_usb}. The proposal has advanced to Phase 1 of the proposal process \cite{proposal_phases} and progress is being made to progress to Phase 2. The proposal contains a \acrshort{WIT} interface which supports enumerating devices, reading descriptors, connecting, reading and writing to devices and getting device connection updates. After doing research on existing similar solutions, such as WebUSB \cite{WebUSB} and libusb \cite{LibUSB}, the proposal has taken inspiration from libusb. This makes it easier for developers to port existing applications to \acrshort{Wasm} as both libusb and \acrshort{WASI} \acrshort{USB} have similar interfaces. Some parts have been made different deliberately, for example the way file handles work. This way, the \acrshort{API} is easier to reason about. As \acrshort{Wasm} is sandboxed by default, access control is provided so programs do not have access to all devices by default. It is up to the user to specify which devices a program can access.

A reference implementation for the \acrshort{API} is provided \cite{wasi_usb} and extends the Wasmtime \cite{wasmtime_website} runtime to provide support for the \acrshort{USB} \acrshort{API}.

The implementation has been evaluated in three ways. First, a functional evaluation was made. In this evaluation, a guest module will observe connection events for a specific game controller, connect to the game controller, read out its state and control its rumble motors, confirming that the most important parts of the \acrshort{API} work.

Afterwards, the implementation has been evaluated for latency and memory usage. This is done by creating a \acrshort{USB} mass storage device driver by using the \acrshort{WASI} \acrshort{USB} \acrshort{API}. The file tree of a \acrshort{USB} drive can be read out and the file contents can be read. Comparing this against a native implementation shows on average a 4.2\% increase in latency, which is a good result. Memory usage using the \acrshort{WASI} \acrshort{API} is significantly higher, with the program using approx. 70\% more memory during heavy workloads, compared to native. This is likely caused by the way the memory model works in the Component Model, requiring the use of copying of data between components.

The \acrshort{WASI} \acrshort{USB} \acrshort{API} still has a long way to go before it is production ready, but the example programs in this thesis show the possibilities of the \acrshort{API} and demonstrate how the \acrshort{API} can be used in real-world use cases.

\newgeometry{top=2.5cm, bottom=1.5cm, right=2cm, left=2cm}
\chapter*{Samenvatting}
\chaptermark{Samenvatting}
\addcontentsline{toc}{chapter}{Samenvatting}  

Het bijwerken van software voor \acrfull{IoT}-apparaten is momenteel moeilijk. Met een langere levensduur dan het gemiddelde gadget, en vaak speciale hardware en compilers die veel onderhoud vereisen, verliezen de meeste \acrshort{IoT}-apparaten te snel softwareondersteuning \cite{wasi_iot}. \acrfull{Wasm}, oorspronkelijk gemaakt om gecompileerde code te laten draaien in een lichtgewicht virtuele machine in de browser, probeert dit probleem aan te pakken door zijn ondersteuning buiten de browser uit te breiden. Vanwege zijn quasi-native prestaties, veiligheid, compactheid en programmeertaal onafhankelijkheid, wint \acrshort{Wasm} aan populariteit voor gebruik op edge-apparaten \cite{wasi_iot}. Echter, \acrshort{Wasm} mist een goede interface voor gebruik buiten de browser. Om dit probleem aan te pakken werd de \acrfull{WASI} geïntroduceerd, met als doel een universele \acrshort{API} te bieden voor alle ondersteunde platforms en talen. \acrshort{WASI} is nog in ontwikkeling en mist momenteel een \acrshort{API} voor het gebruik van USB-apparaten. Het doel van deze thesis is om onderzoek te doen naar en een \acrshort{USB} \acrshort{API} te ontwikkelen voor \acrshort{WASI}.

Een deel van de ontwikkeling omvat het maken van een \textit{proposal} om de standaard uit te breiden, waarin de interface van de \acrshort{API} wordt uiteengezet en andere zaken, zoals platformondersteuning, verder worden besproken. Als onderdeel van deze thesis is een initiëel \textit{proposal} gemaakt \cite{wasi_usb}. Het \textit{proposal} is gevorderd naar Fase 1 van het doorloopproces \cite{proposal_phases} en er worden stappen ondernomen om door te gaan naar Fase 2. Het voorstel bevat een \acrshort{WIT} interface die het mogelijk maakt een lijst van verbonden apparaten op te vragen, \textit{descriptors} uit te lezen, verbinding te maken, te lezen en te schrijven naar apparaten en updates over apparaatverbindingen te krijgen. Na onderzoek naar bestaande vergelijkbare oplossingen, zoals WebUSB \cite{WebUSB} en libusb \cite{LibUSB}, heeft het voorstel inspiratie gehaald uit libusb. Dit maakt het voor ontwikkelaars gemakkelijker om bestaande applicaties naar \acrshort{Wasm} te porteren aangezien zowel libusb als \acrshort{WASI} \acrshort{USB} vergelijkbare interfaces hebben. Sommige delen zijn opzettelijk anders gemaakt, bijvoorbeeld de manier waarop \textit{device handles} werken. Op deze manier is de \acrshort{API} gemakkelijker te begrijpen. Aangezien \acrshort{Wasm} standaard in een sandbox draait, wordt \textit{access control} gebruikt zodat programma’s niet standaard toegang hebben tot alle apparaten. Het is aan de gebruiker om te specificeren welke apparaten een programma kan gebruiken.

Een referentie-implementatie voor de \acrshort{API} wordt geleverd \cite{wasi_usb} en breidt de Wasmtime \cite{wasmtime_website} runtime uit om ondersteuning te bieden voor de \acrshort{USB} \acrshort{API}.

De implementatie is op drie manieren geëvalueerd. Ten eerste werd een functionele evaluatie uitgevoerd. In deze evaluatie observeert een gastmodule verbindingsevenementen voor een specifieke gamecontroller, maakt verbinding met de gamecontroller, leest de status ervan uit en bestuurt de trilmotoren, waarmee wordt bevestigd dat de belangrijkste onderdelen van de \acrshort{API} werken.

Vervolgens is de implementatie geëvalueerd op vertraging en geheugengebruik. Dit werd gedaan door een \acrshort{USB} mass storage apparaatstuurprogramma te creëren met behulp van de \acrshort{WASI} \acrshort{USB} \acrshort{API}. De bestandsstructuur van een \acrshort{USB}-schijf kan worden uitgelezen en de inhoud van bestanden kan worden gelezen. Een vergelijking met een native implementatie toont gemiddeld een vertraging van 4,2\%, wat een goed resultaat is. Het geheugengebruik van de \acrshort{WASI} \acrshort{API} is significant hoger, waarbij het programma ongeveer 70\% meer geheugen gebruikt tijdens zware werkbelasting, vergeleken met een native programma. Dit wordt waarschijnlijk veroorzaakt door de manier waarop het geheugenmodel werkt in het Component Model, dat vereist dat gegevens worden gekopieerd tussen componenten.

De \acrshort{WASI} \acrshort{USB} \acrshort{API} heeft nog een lange weg te gaan voordat het klaar is om gebruikt te worden, maar de voorbeeldprogramma’s in deze thesis laten de mogelijkheden van de \acrshort{API} zien en demonstreren hoe de \acrshort{API} kan worden gebruikt in echte gebruikersscenario's.
\restoregeometry