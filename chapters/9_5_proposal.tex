\chapter{Proposal}

\section{Standardization}
The goal of this master's thesis is to extend the WASI standard with a new USB API. In order to do this, the API must go through a standardization process. This way, a consensus can be made about how the API should work, which platforms it will work on, and what its scope is. When gone through the proposal, one universal API can be offered that is supported by all runtimes which are WASI-compliant.

In order for the USB API to take part in this standardization process, a proposal must be created. This proposal contains all ideas and information required to create an implementation for the API. Throughout the standardization process, the proposal will go through 5 stages:

\paragraph{Phase 0 (Pre-Proposal)}
When there is enough interest in a proposal and the idea seems viable, the proposal gets discussed in an online WASI meeting. The person who will create the proposal explains the idea, what it would solve, and how it can and cannot be used. This is often also the first moment to get feedback from the community. Each attendee of the meeting casts a vote about the idea. If the majority of the people approve, the idea can move to Phase 1, and a proposal can be created. Champions (people that will create the proposal) get assigned to the proposal.

At the time of writing, \texttt{wasi-usb} is in Phase 1.

\paragraph{Phase 1}
To be able to move to phase 2, the requirements for phase 1 are worked out:
\begin{itemize}
\item The WIT interface gets created and documented by the champions. The WIT interface should be mostly finalized, but small changes can occur.
\item Prototype implementations are required to evaluate the viability of the created API.
\item The portability criteria are defined:
\begin{itemize}
\item Portability: On which platforms should the API run, what parts of the API are available on which platform.
\item Practicality: The proposal should demonstrate that the API can be used in real-world scenarios.
\item Testing: Define how the API should be tested and on which devices.
\item Implementations: In Phase 3, each proposal should have at least two implementations in different WASI runtimes. The kinds of implementations are defined here.
\end{itemize}
\end{itemize}

These portability criteria are defined in this phase, but get worked out in the later phases.
Once these requirements are met, the proposal can move to phase 2.

\paragraph{Phase 2}
During phase 2, one host implementation is created to test the API. Dependencies of the implementation should have already reached at least stage two.
Furthermore, a plan is developed for how the portability criteria will be met.

\paragraph{Phase 3}
In Phase 3, extra implementations of the API are made in different WASI runtimes. All implementations should pass the testing defined in the portability criteria and be complete. In addition, the dependencies used in the implementation should have reached the proposal phase 3. To further test the API, Libraries and other tools that use the API are built.

\paragraph{Phase 4 \& 5}

No proposal has reached phase 4 yet, so the requirements of phase 4 \& 5 is not final yet. These stages finalize the standardization of the API.


A full overview of phase requirements can be found \href{https://github.com/WebAssembly/meetings/blob/main/process/phases.md}{here} \footnote{https://github.com/WebAssembly/meetings/blob/main/process/phases.md}.

\section{USB Proposal}
The \texttt{wasi-usb} repository \cite{wasi_usb} has been created and contains the contents of the proposal to standardize the USB interface. The proposal contains a draft of the \acrshort{WIT} interface of the USB API. This section will highlight the important parts of the API.

An important note is that in this chapter, `WIT interface' and `interface' will both be used, but have a different meaning.
WIT interface refers to the whole WIT file.
A WIT file itself also contains interfaces, which are also discussed here as interfaces. An interface can be thought of as an instance in the WebAssembly Component Model, for example a unit of functionality imported from the host or implemented by a component for consumption on a host. All functions and types belong to an interface. \footnote{https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md\#wit-interfaces}

\paragraph{\texttt{imports} World}
The \texttt{imports} world in code snippet \ref{code:world} is the main entrypoint of the interface. It imports 4 interfaces: \texttt{types}, \texttt{descriptors}, \texttt{events} and \texttt{usb}. These are separate files with different parts of the WIT interface. The world imports them so they are included in the WIT interface. The world will also export these interfaces, making them available for components that use the \texttt{imports} world.\\

\begin{code}
\begin{verbatim}
package component:usb@0.2.0;

world imports {
	import types;
	import descriptors;
	import events;
	import usb;

	export types;
	export descriptors;
	export events;
	export usb;
}
\end{verbatim}
\caption{\texttt{imports} World}
\label{code:world}
\end{code}

\paragraph{\texttt{usb} interface}
The \texttt{usb} interface seen in code snippet \ref{code:usb_interface} contains two resources: \texttt{usb-device} and \texttt{device-handle}. The \texttt{usb-device} resource contains a static function \texttt{enumerate}, with which all available USB devices can be retrieved. These will be returned as instances of \texttt{usb-device}. The other 3 methods can be used on one of these instances. The \texttt{device-descriptor} and \texttt{configurations} functions will both return extra information about a device and are always available. That is, they do not need to have exclusive access to these devices to obtain that information. The \texttt{open} function is different in this regard. This function will establish a context with which you can communicate with the device. One important aspect is that opening a device can fail due to various reasons. For example, some operating systems might deny opening a device if the executable does not have enough permissions. These permissions are handled at a \acrshort{Wasm} runtime level, and are not specific to \acrshort{Wasm} modules. To create a robust and intuitive API, functions that require an `open' device are scoped to the \texttt{device-handle} resource, which can only be obtained if a device can be opened successfully.

The \texttt{device-handle} resource will contain all the functions which require communicating with a device. For example, 

\begin{code}
\begin{verbatim}
package component:usb@0.2.0;

interface usb {
	use types.{device-handle-error};
	use descriptors.{configuration-descriptor, device-descriptor};

	resource usb-device {
		// Get a list of all configurations of the USB device.
		configurations: func() -> 
			result<list<configuration-descriptor>, device-handle-error>;

		device-descriptor: func() -> device-descriptor;

		// Open the device. If successfull, this will return 
		// a device handle which can be used to interact with the device.
		open: func() -> result<device-handle, device-handle-error>;

		// Get a list of all USB devices the guest is allowed to access.
		enumerate: static func() -> list<usb-device>;
	}

	resource device-handle {
		reset: func();
		active-configuration: func() -> result<u8, device-handle-error>;

		select-configuration: func(configuration: u8);

		// **Interfaces**

		// Claim an interface.
		// Claiming an interface can fail.
		// For example, the operating system might not allow claiming the interface.
		claim-interface: func(%interface: u8) -> result<_, device-handle-error>;

		// Release an interface.
		release-interface: func(%interface: u8);

		// Select an alternate interface.
		select-alternate-interface: func(%interface: u8, setting: u8) -> 
			result<_, device-handle-error>;

		// **Reading & Writing**

		read-interrupt: func(endpoint: u8) -> 
			result<tuple<u64, list<u8>>, device-handle-error>;
			
		write-interrupt: func(endpoint: u8, data: list<u8>) -> 
			result<u64, device-handle-error>;

		read-bulk: func(endpoint: u8, max-size: u16) -> 
			result<tuple<u64, list<u8>>, device-handle-error>;
			
		write-bulk: func(endpoint: u8, data: list<u8>) -> 
			result<u64, device-handle-error>;

		read-isochronous: func(endpoint: u8) -> 
			result<tuple<u64, list<u8>>, device-handle-error>;
			
		write-isochronous: func(endpoint: u8, data: list<u8>) -> 
			result<u64, device-handle-error>;

		read-control: func(request-type: u8, request: u8, value: u16, 
			index: u16, max-size: u16) -> result<tuple<u64, list<u8>>, device-handle-error>;
			
		write-control: func(request-type: u8, request: u8, value: u16, 
			index: u16, buf: list<u8>) -> result<u64, device-handle-error>;
	}
}
\end{verbatim}
\caption{\texttt{usb} interface}
\label{code:usb_interface}
\end{code}

\section{Capability-based security}

\section{Timeline}

\begin{table}[h]
	\centering
	\begin{tabular}{l|p{12cm}}
		\toprule
		\textbf{Date} & \textbf{Event} \\
		\midrule
		29 November 2023 & An issue \cite{wasi_issue_570} was created on the WASI repository, stating the interest in creating an USB proposal. Proposal is at phase 0. \\
		5 March 2024 & Initial WIT for proposal created with Warre \\
		4 April 2024 & Presentation \cite{wasi_meeting_notes} of proposal in WASI meeting. Proposal has moved to phase 1 \\
		\bottomrule
	\end{tabular}
	\caption{Timeline of Events Related to the USB Proposal in the WASI Repository}
	\label{tab:wasi_usb_proposal}
\end{table}
