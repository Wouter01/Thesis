\chapter{Proposal}

\section{Standardization}
The goal of this master's thesis is to extend the \acrshort{WASI} standard with a new \acrshort{USB} \acrshort{API}. In order to do this, the \acrshort{API} must go through a standardization process. This way, a consensus can be made about how the \acrshort{API} should work, which platforms it will work on, and what its scope is. When gone through the proposal, one universal \acrshort{API} can be offered that is supported by all runtimes which are \acrshort{WASI}-compliant.

In order for the \acrshort{USB} \acrshort{API} to take part in this standardization process, a proposal must be created. This proposal contains all ideas and information required to create an implementation for the \acrshort{API}. Throughout the standardization process, the proposal will go through five phases \cite{proposal_phases}:

\paragraph{Phase 0 (Pre-Proposal)}
When there is enough interest in a proposal and the idea seems viable, the proposal gets discussed in an online WASI meeting. The person who will create the proposal explains the idea, what it would solve, and how it can and cannot be used. This is often also the first moment to get feedback from the community. Each attendee of the meeting casts a vote about the idea. If the majority of the people approve, the idea can move to Phase 1, and a proposal can be created. Champions (people that will create the proposal) get assigned to the proposal.

At the time of writing, \texttt{wasi-usb} is in Phase 1.

\paragraph{Phase 1}
To be able to move to phase 2, the requirements for phase 1 are worked out:
\begin{itemize}
\item The \acrshort{WIT} interface gets created and documented by the champions. The \acrshort{WIT} interface should be mostly finalized, but small changes can occur.
\item Prototype implementations are required to evaluate the viability of the created \acrshort{API}.
\item The portability criteria are defined:
\begin{itemize}
\item Portability: On which platforms should the \acrshort{API} run, what parts of the \acrshort{API} are available on which platform.
\item Practicality: The proposal should demonstrate that the \acrshort{API} can be used in real-world scenarios.
\item Testing: Define how the \acrshort{API} should be tested and on which devices.
\item Implementations: In Phase 3, each proposal should have at least two implementations in different \acrshort{WASI} runtimes. The kinds of implementations are defined here.
\end{itemize}
\end{itemize}

These portability criteria are defined in this phase, but get worked out in the later phases.
Once these requirements are met, the proposal can move to phase 2.

\paragraph{Phase 2}
During phase 2, one host implementation is created to test the \acrshort{API}. Dependencies of the implementation should have already reached at least stage two.
Furthermore, a plan is developed for how the portability criteria will be met.

\paragraph{Phase 3}
In Phase 3, extra implementations of the \acrshort{API} are made in different \acrshort{WASI} runtimes. All implementations should pass the testing defined in the portability criteria and be complete. In addition, the dependencies used in the implementation should have reached the proposal phase 3. To further test the \acrshort{API}, Libraries and other tools that use the \acrshort{API} are built.

\paragraph{Phase 4 \& 5}

No proposal has reached phase 4 yet, so the requirements of phase 4 \& 5 is not final yet. These stages finalize the standardization of the \acrshort{API}.


A full overview of phase requirements can be found \href{https://github.com/WebAssembly/meetings/blob/main/process/phases.md}{here} \footnote{https://github.com/WebAssembly/meetings/blob/main/process/phases.md}.

\section{Timeline}
Table \ref{tab:wasi_usb_proposal} shows the timeline of events that happened during the year regarding the proposal. At the time of writing, the \acrshort{WASI} \acrshort{USB} proposal is in Phase 1.

\begin{table}[h]
	\centering
	\begin{tabular}{l|p{12cm}}
		\toprule
		\textbf{Date} & \textbf{Event} \\
		\midrule
		29 November 2023 & An issue \cite{wasi_issue_570} was created on the WASI repository, stating the interest in creating an USB proposal. Proposal is at phase 0. \\
		5 March 2024 & Initial WIT for proposal created\\
		4 April 2024 & Presentation \cite{wasi_meeting_notes} of proposal in WASI meeting. Proposal has moved to phase 1 \\
		\bottomrule
	\end{tabular}
	\caption{Timeline of events related to the USB proposal in the WASI repository.}
	\label{tab:wasi_usb_proposal}
\end{table}
\newpage
\section{Architecture}

This section briefly explains how the different parts of the \acrshort{API} work together. A visualisation of the parts can be seen in Figure \ref{image:api_areas}.


\begin{figure}[!h]
\centering
\begin{tikzpicture}
	[mynode/.style = {rectangle, draw, align=center, 
			inner xsep=6mm, inner ysep=3mm},
	-latex,     
	]

	% nodes
	\node[mynode] (inner) {Guest (Wasm Module)};
	\node[mynode,  left=15mm of inner.west] (wasiusb) {WASI USB};
	\node[label={}, above=10mm of inner.west] (title) {Wasm Runtime};

	\node[fit={(inner) (wasiusb) (title)}, draw] (outer) {};
	
	\node[mynode, below=10mm of wasiusb.south] (libusb) {libusb};
	\node[mynode, right=10mm of libusb.east] (nativeusb) {Operating System USB API};

	% connections
	\draw [<->, very thick] (wasiusb.east) to node[midway, above] {WIT} (inner.west);
	\draw [<->, very thick] (wasiusb.south) to (libusb.north);
	\draw [<->, very thick] (libusb.east) to (nativeusb.west);
\end{tikzpicture}
\caption{Internals of the \acrshort{WASI} \acrshort{USB} \acrshort{API}. The arrows represent communication between the different areas.}
\label{image:api_areas}
\end{figure}

\paragraph{Guest} This is a \acrshort{Wasm} module that is created by a user of the \acrshort{API}. It contains code that utilizes the API to communicate with devices. The guest module is sandboxed in the \acrshort{Wasm} runtime, meaning that it cannot access any system resources. By utilizing the WASI APIs, such as the \acrshort{WASI} \acrshort{USB} \acrshort{API}, it can get access to system resources. It can communicate with the runtime implementation through the \acrshort{WIT} interface.

\paragraph{WASI USB} This is the host implementation of the \acrshort{WASI} \acrshort{USB} \acrshort{API}. It acts as a bridge between native \acrshort{USB} \acrshort{API}s and \acrshort{Wasm} modules. This piece is part of the \acrshort{Wasm} Runtime, but is not sandboxed, so it can access system resources. To do this, the code is not compiled to \acrshort{Wasm} but is instead part of the native runtime binary. This code is platform-dependent and must ensure the exposed \acrshort{API} works as similar as possible on each supported platform.

\paragraph{libusb} To help the \acrshort{WASI} \acrshort{USB} runtime implementation having similar behavior on different platforms, libusb is used. libusb is a lightweight wrapper around native USB APIs \cite{LibUSB}, but abstracts them to a universal interface. By using libusb, the runtime implementation can be written against the libusb API instead of the need to provide separate implementations for each platform.

\paragraph{Operating System USB API} Finally, libusb will call the native libusb APIs. These are provided by the Operating System kernel.

\section{USB Proposal}
\label{section:usb_proposal}
The \texttt{wasi-usb} repository \cite{wasi_usb} contains the contents of the proposal to standardize the USB interface. The proposal contains a draft of the \acrshort{WIT} interface of the USB API. This section will highlight the important parts of the API.

An important note is that in this chapter, `WIT interface' and `interface' will both be used, but have a different meaning.
\acrshort{WIT} interface refers to the whole WIT file.
A WIT file itself also contains interfaces, which are also discussed here as interfaces. An interface can be thought of as an instance in the WebAssembly Component Model, for example a unit of functionality imported from the host or implemented by a component for consumption on a host. All functions and types belong to an interface \cite{wit_interfaces}.

\paragraph{\texttt{imports} World}
The \texttt{imports} world in code snippet \ref{code:world} is the main entry point of the interface. It imports 4 interfaces: \texttt{types}, \texttt{descriptors}, \texttt{events} and \texttt{usb}. These are separate files with different parts of the WIT interface. The world imports them so they are included in the WIT interface. The world will also export these interfaces, making them available for components that use the \texttt{imports} world.\\

\begin{code}
\lstinputlisting[breaklines, language=wit]{WIT/wit/world.wit}
\caption{\texttt{imports} world.}
\label{code:world}
\end{code}

\paragraph{\texttt{usb} interface}
The \texttt{usb} interface seen in code snippet \ref{code:usb_interface} contains two resources: \texttt{usb-device} and \texttt{device- handle}. Some details of the interface are omitted for brevity. The \texttt{usb-device} resource contains a static function \texttt{enumerate}, with which all available USB devices can be retrieved. These will be returned as instances of \texttt{usb-device}. The other three methods can be used on one of these instances. The \texttt{device-descriptor} and \texttt{configurations} functions will both return extra information about a device and are always available. That is, they do not need to have exclusive access to these devices to obtain that information. The \texttt{open} function is different in this regard. This function will establish a context with which you can communicate with the device. One important aspect is that opening a device can fail due to various reasons. For example, some operating systems might deny opening a device if the executable does not have enough permissions. These permissions are handled at a \acrshort{Wasm} runtime level, and are not specific to \acrshort{Wasm} modules. To create a robust and intuitive \acrshort{API}, functions that require an `open' device are scoped to the \texttt{device-handle} resource, which can only be obtained if a device can be opened successfully.

The \texttt{device-handle} resource will contain all the functions which require communicating with a device. For example, you are able to fetch the active configuration of a device. Functions exist to read and write using the four transfer types (see \ref{section:transfer_types}): \texttt{read-interrupt}, \texttt{write-interrupt}, etc. Most functions in \texttt{device-handle} are closely related to similar libusb functions \cite{libusb_docs}. \\

\begin{code}
\begin{lstlisting}[breaklines, language=wit, tabsize=2]
package component:usb@0.2.0;

~interface~ usb {
	use types.{usb-error};
	use descriptors.{configuration-descriptor, device-descriptor};

	type duration = u64;

	resource usb-device {
		// Get a list of all configurations of the USB device.
		configurations: func() -> result<list<configuration-descriptor>, usb-error>;

		device-descriptor: func() -> device-descriptor;

		// Open the device. If successfull, this will return a device handle which can be used to interact with the device.
		open: func() -> result<device-handle, usb-error>;

		// Get a list of all USB devices the guest is allowed to access.
		enumerate: static func() -> list<usb-device>;
	}

	resource device-handle {
		reset: func() -> result<_, usb-error>;
		active-configuration: func() -> result<u8, usb-error>;

		select-configuration: func(configuration: u8) -> result<_, usb-error>;

		// **Interfaces**

		// Claim an interface.
		// Claiming an interface can fail. For example, the operating system might not allow claiming the interface.
		claim-interface: func(%interface: u8) -> result<_, usb-error>;

		// Release an interface.
		release-interface: func(%interface: u8);

		// Select an alternate interface.
		select-alternate-interface: func(%interface: u8, setting: u8) -> result<_, usb-error>;

		// **Reading & Writing**

		read-interrupt: func(...) -> ...;
		write-interrupt: func(...) -> ...;

		read-bulk: func(...) -> ...;
		write-bulk: func(...) -> ...;

		read-isochronous: func(...) -> ...;
		write-isochronous: func(...) -> ...;

		read-control: func(...) -> ...;
		write-control: func(...) -> ...;
	}
}
\end{lstlisting}
\caption{\texttt{usb} interface.}
\label{code:usb_interface}
\end{code}

\paragraph{\texttt{events} interface}

Code snippet \ref{code:events_interface} shows the \texttt{events} interface. This interface allows a guest to poll for connection event updates. This way, a guest can know when a device gets connected or disconnected and act appropriately. It only contains a single function, \texttt{update}. As the name implies, this function will return a \texttt{device-connection-event}. When no update is available, the \texttt{pending} case will be returned.

When \acrshort{WASI} Preview 3 brings async support, the \texttt{update} function can be adjusted so it can get updates via a stream instead of polling.\\

\begin{code}
\begin{lstlisting}[language=wit, tabsize=4]
package component:usb@0.2.0;

~interface~ events {
	use usb.{usb-device};

	variant device-connection-event {
		|pending|,
		|connected|(usb-device),
		|disconnected|(usb-device)
	}

	update: func() -> device-connection-event;
}
\end{lstlisting}
\caption{\texttt{events} interface.}
\label{code:events_interface}
\end{code}

\section{Capability-based security}
\label{section:capability_based_security}
One of the strenghts of \acrshort{WASI} is the capability-based security mechanism it brings. This mechanism allows granular control of what resources an application is allowed to access. For example, the \acrshort{WASI} filesystem APIs apply capability-based security, so applications only have access to files and directories they have been given access to \cite{wasi_security}.

The \acrshort{USB} proposal aims to add a similar security model for accessing USB devices. This idea can be applied at various levels:
\begin{itemize}
\item Device-level: Only allow devices with specified vendor / product ID pairs.
\item Configuration-level: Only allow devices with certain configuration types. For example, only allow self-powered devices.
\item Interface-level: Only allow interfaces with certain kinds of properties. For example, only allow interfaces that have the mass storage device class code.
\item Endpoint-level: Only allow endpoints with certain kinds of properties. For example, only allow endpoints with an \textit{IN} direction, limiting the guest to only receive data.
\end{itemize}

The current proposal draft only applies this security model at the \textbf{device-level}. This option is the most obvious one, and is similar to the way WebUSB protects devices \cite{webusb_security}. Applying the security model to the other three levels is possible, but it is not known yet if this would provide any benefits. Therefore, these levels have been left out of the security model for now. Community feedback will be essential to determine if these options are useful.

\subsection{Implementation Considerations}
When implementing the security model at a device-level, the \acrshort{Wasm} runtime should take following measures:
\begin{itemize}
\item Extend runtime parameters so users can add allowed devices. These devices would likely be matched against a manufacturer and product ID pair. If proven useful, an extra parameter can also be provided to use a blacklist instead of a whitelist. This way, the user can provide which devices cannot be accessed.
\item Change the \texttt{usb.\{usb-device/enumerate\}} function implementation, so that it filters out all non-allowed devices.
\item Change the \texttt{events.\{update\}} function implementation, so it does not give update events about non-allowed devices.
\end{itemize}

If the security model would be applied to any of the three other levels, modification of the \texttt{device-handle} resource will be needed, as certain parameters will not be allowed anymore. For example, the \texttt{select-configuration} function accepts any configuration number, while some configurations might not be allowed by the security model. To solve this issue, two solutions are possible:

\begin{itemize}
\item All permission-sensitive functions can throw errors when illegal numbers are passed.
\item Resources are used instead of numbers to represent configurations, interfaces and endpoints.
\end{itemize}

The second option would create a more intuitive API, as less errors can be thrown. Instead of passing an arbitrary number, a resource can be passed. This resource can only be created by the host runtime implementation, so the guest cannot pass a resource it does not have access to. A downside of this approach would be that it differs more from the simplicity of the \textit{classic} \acrshort{USB} \acrshort{API}.

\section{Usage in multiple components}
\label{section:usage_in_multiple_components}
It is possible that multiple components interact with the \acrshort{USB} \acrshort{API} and try accessing a \acrshort{USB} device at the same time. This should be avoided, as a component generally expects to have exclusive access to a device. To solve this issue, the runtime should keep track of which devices are used by which components, and deny opening a device when another component is already using it. This approach follows the same model as most operating systems, where only one program can have access to a \acrshort{USB} device at a time.