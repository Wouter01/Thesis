\chapter{Evaluation}

\section{Functional Evaluation}
\label{section:functional_evaluation}
When developing the API, it is useful to already have guest code utilizing the API to quickly iterate. The following proof of concept is one of the guest programs created to test the API. It touches on all the parts of the API: getting device updates and receiving and sending data through the USB interface. As it is a proof of concept, it does not test the performance of the API.

The general idea of the program is to control a game controller. The program is started and observes the connected devices. Once a controller is connected that is recognized by the program, the program will connect to the controller. The state of all the controls of the device will be read, and input updates will be print out. To test sending data over the USB interface, the program will send commands to the controller to activate the rumble motors \footnote{Rumble motors are used to vibrate the controller}.

\subsection{Test Setup}
The code will call the event-related API to start watching for USB devices. It will get events when devices are connected or disconnected. As WASI does not support asynchronous code yet, a form of polling is used to get device connection events. The guest code uses a single-threaded asynchronous runtime, which will often yield to get new device connection events. This way, a multi-threaded real app can be simulated.

\begin{enumerate}
\item Each time a device connection event happens, the device product and vendor ID are checked to see if they match the predefined controller product and vendor ID. A Google Stadia controller is used to test this code, so the IDs of this controller type are used.

\item Make a connection and open a device handle if the device IDs match.

\item Select the correct configuration and interface. Input devices, like controllers or mice, send their data over the Interrupt transfer type, because the data sent is small and time-sensitive. Knowing this information, the interfaces can be requested and filtered to select the correct interface. macOS is used to run this example which offers default drivers for controllers, so elevated privileges are needed to detach the kernel drivers. Otherwise, the program cannot claim the interrupt interface.

\item Read the controller state from the interrupt interface, such as which buttons are pressed, what the position of the joysticks is, etc. An array of bytes is received, and by observing changes to this array when pressing a button, the byte layout can be decoded.

\item Print out the controller state. A sample output is showed in Code snippet \ref{code:wasi_controller_sample_output}.

\item Make the controller vibrate. This happens when the program state reports that one of the shoulder buttons has registered pressure. The state of the shoulder buttons is mapped to intensity of the rumble motors. This data is sent over the interrupt interface. When the controller receives the data it starts vibrating.

\item When a device disconnection event with matching IDs happens, the program will stop reading the controller state, close the device handle, and wait for a new connection.


\end{enumerate}

% Each time a device connection event happens, the device product and vendor ID are checked to see if they match the predefined controller product and vendor ID. A Google Stadia controller is used to test this code, so the IDs of this controller type are used. If the IDs match, a connection is made to the device by opening a device handle. When a device disconnection event with matching IDs happens, the program will stop reading the controller state, and wait for a new connection.
% 
% Next, the program will try reading the controller state. This way, it knows about the positions of buttons, joysticks, triggers, etc. In order to do this, the correct interface and endpoint must be chosen. Input devices, like controllers or mice, send their data over the Interrupt transfer type, because the data sent is small and time-sensitive. Knowing this information, the interfaces can be requested and filtered to select the correct interface. In order to send information over the interface, it must first be claimed by the program. Some operating systems will attach to the interfaces by default. The host code of the API will automatically disconnect kernel attachments when claiming an interface. However, different operating systems can have different behavior in this part. For example, macOS, where the example program was ran on, does not allow detaching kernel interfaces by default for certain device classes, such as controllers. This is problematic, as we cannot interact in any way with the device this way. Elevated privileges (\texttt{sudo}) were required to get the program working. While being annoying, this was also a useful discovery, as this issue can be added to the proposal, so the standard can adjust to this.
% 
% Once the interface is claimed, device state can be requested by reading the interrupt state with the correct endpoint address. An array of bytes will be received, and by observing what changes when pressing a button, the byte layout can be decoded. A sample controller state output is showed in Code snippet \ref{code:wasi_controller_sample_output}.

\begin{code}
\begin{verbatim}

dpad: ,
buttons: assistant_button|l2_button|r2_button,
left stick: x: 128 y: 128,
right stick: x: 128 y: 128,
l2: 255,
r2: 172
\end{verbatim}
\caption{Output after reading controller state}
\label{code:wasi_controller_sample_output}
\end{code}

\subsection{Results}
This program has been tested with a Google Stadia controller. When pressing one or multiple buttons, the correct state is printed out. When pressing one or both of the shoulder buttons, the controller starts to vibrate.



\section{Hardware Configuration}

Tests were performed to evaluate the performance of the API. In these tests, test programs are created which run in WASI, as a native program or, when available, on Wasm in the browser. Table \ref{table:test_hardware} shows the hardware configurations of the devices used to do these tests.

\begin{table}[H]
\[
\begin{array}{|l|l|l|l|l|l|}
\hline
\textbf{Device} & \textbf{Name} & \textbf{SoC/Microcontroller} & \textbf{RAM} & \textbf{Storage} & \textbf{USB Version} \\
\hline
\text{Host} & \text{Apple Macbook Air (2020)} & \text{Apple M1 (8-core CPU, 7-core GPU)} & \text{8GB} & \text{256GB SSD} & \text{4.0} \\

\hline
\text{Guest} & \text{Arduino Micro} & \text{Atmel ATmega32U4} & \text{2,5KB} & \text{32KB Flash} & \text{2.1} \\

\hline
\text{Guest} & \text{Samsung T5} & \text{} & \text{} & \text{500GB SSD} & \text{3.1 Gen 2} \\
\hline
\end{array}
\]
\caption{The hardware used for testing the performance of the API}
\label{table:test_hardware}
\end{table}


\section{Latency Evaluation}

One of the advantages of \acrshort{Wasm} should be that it offers near-native speed. Therefore, it is interesting to test if running a program in Wasm brings any performance overhead compared to a native program. For an USB API, this can best be tested by measuring the latency when sending or receiving data. It can be problematic if the overhead is large, as data exchange through USB happens by receiving or sending data in small chunks. Each of these chunks has to pass through the Wasm bridge and has its own overhead.

\subsection{Receiving data from Arduino}

\subsubsection{Test Setup}
A program has been written with LibUSB (Native), WASI USB (Wasm) and WebUSB (Browser). Each program will do the following steps:

\begin{enumerate}
\item Enumerate the USB devices.
\item Find the Arduino board, based on its product and vendor id.
\item Open the device and claim the Bulk interface.
\item Send the \acrfull{DTR} signal to the Arduino. This signal is sent to the Arduino to acknowledge that the host device is ready to receive data. Once the Arduino has received this signal, its setup phase is completed and it will start sending data.
\item \textit{Warm up } the interface by throwing away the first batch of readings. By doing this, initial latency is removed from the measurements.
\item Read data from the Bulk interface, while measuring how long this operation takes. The arduino sends data in batches in 64 bytes, and the program will read them a million times. The program will throw away the read results, so only the transfer of the data is measured. In total, 64MB is received by the host.
\item Write durations to file.
\end{enumerate}

\subsubsection{Results}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/arduino_latency_boxplot.png}
  \caption{Latency of reading data from Arduino using read-bulk}
  \label{fig:arduino_reading_latency_boxplot}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/reading_data_latency.png}
  \caption{Latency of reading data from Arduino using read-bulk}
  \label{fig:arduino_reading_latency}
\end{figure}




\paragraph{Interpreting Results}
Figure \ref{fig:arduino_reading_latency_boxplot} shows the the latency of both programs on a logarithmic scale. This happens

Figure \ref{fig:arduino_reading_latency} shows a \acrfull{KDE} for the measurements of the native and \acrshort{WASI} implementation.
Both graphs will show peaks around the 150μs and 910μs marks. This is an interesting result, as one would expect one uniform distribution instead of two. The first peak is trivial to explain: the Arduino is an USB 2.0 device, also known as a High-speed USB device. A High-speed USB device will send frames at a fixed interval of 125μs. Therefore, we will receive new data approx. every 125μs. An extra 25μs are introduced because of processing delays. 

The second peak is more nuanced. Table \ref{table:arduino_output} shows a snippet of the measured latencies. For both Native and WASI code, the latencies will oscillate between both peaks. Based on these results, this peak is likely caused by the small buffer size in the Arduino. The buffer is 64 bytes large, which is the same size as one packet. When the buffer is full, the program halts until the buffer has space again. On the host this is perceived as an extra delay when receiving the data.

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Native (μs)} & \textbf{WASI (μs)} \\
\hline
801 & 918 \\
\hline
150 & 163 \\
\hline
885 & 931 \\
\hline
132 & 241 \\
\hline
903 & 799 \\
\hline
110 & 197 \\
\hline
938 & 820 \\
\hline
104 & 77 \\
\hline
962 & 1003 \\
\hline
108 & 97 \\
\hline
\end{tabular}
\caption{Snippet of measured latencies. The latencies oscillate between a long latency and a short latency.}
\label{table:arduino_output}
\end{table}

Based on the results, we can conclude that there are no measurable differences between the different implementations of the program. However, this is mainly caused by the delay of the USB protocol. This delay vastly outweighs the delays caused by overhead of the Wasm runtime, making the Wasm overhead negligible.

However, it is possible that the delay of the USB protocol is smaller on devices more powerful than an Arduino or with a more modern USB version. With these configurations, it can be possible a small overhead for Wasm becomes visible.

\subsection{Reading files from mass storage device}

In order to confirm that WASI does not add noticeable latency, a new benchmark was added which reads the contents of an USB mass storage device. The advantage of this benchmark compared to the Arduino benchmark is that it better represents real-world usage, instead of being a synthetic benchmark.

\subsubsection{Test Setup}
A program has been written which enumerates the file tree of a USB device and reads the contents of each file in the file tree. A Samsung T5 External SSD is used to perform these tests. The device is connected with a cable that supports a transfer speed up to 5Gb/s. The device is formatted with the MBR partition map and the EXFat file system. Communication with the device happens over the SCSI interface. The program uses a EXFat package, which uses a generic interface which works similar to a file handle to communicate with the USB device. A SCSI adapter has been written which will read blocks of the USB device. A cache is used to simulate typical behaviour of a USB mass storage driver.

The program can be split up in these steps:

\begin{enumerate}
\item Enumerate all devices. Select the first device which contains an interface with class code \texttt{0x08} and protocol code \texttt{0x50}. \texttt{0x08} is the identifier for a mass storage device, \texttt{0x50} is for bulk-only transport mode which is used for this test. Select the configuration and interface.

\item Send the \texttt{test\_unit\_ready} signal to check if the device is ready to communicate.

 
\end{enumerate}


An overview of the file tree of the USB device is the following:

\begin{verbatim}
[128K]  /Volumes/Untitled
├── [128K]  folder0
│   ├── [4.0M]  Chapter 1.pdf
│   ├── [ 17M]  Chapter 1.pptx
│   ├── [1.0M]  Chapter 2.pdf
│   ├── [1.3M]  Chapter 2.pptx
│   ├── [1.4M]  Chapter 3.pdf
│   ├── [2.5M]  Chapter 3.pptx
│   ├── [780K]  Chapter 4.pdf
│   ├── [1.1M]  Chapter 4.pptx
│   ├── [642K]  Chapter 5.pdf
│   ├── [1.0M]  Chapter 5.pptx
│   └── [1.9K]  Table of Contents.html
├── [128K]  folder1
│   ├── [ 964]  Table of Contents.html
│   ├── [351K]  document.pdf
│   ├── [140K]  document2.pdf
│   ├── [4.2K]  import.cypher
│   ├── [1.3M]  nodes.csv
│   └── [2.9M]  relationships.csv
└── [128K]  folder2
    ├── [ 964]  Table of Contents.html
    ├── [351K]  document.pdf
    ├── [140K]  document2.pdf
    ├── [4.2K]  import.cypher
    ├── [1.3M]  nodes.csv
    └── [2.9M]  relationships.csv
\end{verbatim}

The program enumerates the file tree and will read out the contents of each file, and report each file size and name. This is repeated 100 times.

\subsubsection{Results}

Figure \ref{fig:mass_storage_latency_naive} shows a boxplot with the results of reading the file tree and file contents of the device. With a lower average and median, the \acrshort{WASI} program seems to outperform the native program. The average execution time of the native program is 12\% slower than the \acrshort{WASI} program, the median execution time is 18\% slower. This is odd, as one would expect the native version to be faster.

However, there is an explanation for this behaviour. The program will read out the entire contents of the disk, which is in total around 3GB. Each file will be loaded into memory and immediately discarded. The disk contains a few files with a size of over 500MB. Loading these files into memory becomes expensive due to the amount of \texttt{malloc}s that need to happen. Profiling the code shows more insights.

The code is compiled in debug mode so debug symbols are added to both programs, so we can interpret the system calls easier. This will lead to a significantly slower running program, especially for the \acrshort{WASI} program. This is not a problem as the profiling is only used to measure memory usage and not speed. The sample size is also lowered to 10 samples instead of 1000.

Figure \ref{fig:malloc_instruments} shows the total time spent on \texttt{malloc} for the native program. 25\% of the execution time was spent on allocating memory, which is a significant amount. Figure \ref{fig:malloc_wasi_instruments} shows that the \acrshort{WASI} program only spends 0,6\% of its execution time on \texttt{malloc} and therefore does not have this issue. This happens because of the way a \texttt{Store} works in Wasmtime: \say{A Store is intended to be a short-lived object in a program. No form of GC is implemented at this time so once an instance is created within a Store it will not be deallocated until the Store itself is dropped.} \cite{wasmtime_store}. Because no memory is freed, the already-allocated memory can be reused, avoiding extra \texttt{malloc} and \texttt{free} calls. A Wasmtime \texttt{Store} therefore can act as a memory pool, which can be significantly faster than using \texttt{malloc} \cite{memory_pool_wikipedia}.


\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/malloc_screenshot.png}
  \caption{approx. 25\% of the native program execution time is spent on \texttt{malloc}}
  \label{fig:malloc_instruments}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/malloc_wasi_screenshot.png}
  \caption{approx. 0.6\% of the \acrshort{WASI} program execution time is spent on \texttt{malloc}}
  \label{fig:malloc_wasi_instruments}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/mass_storage_1000_runs_naive.png}
  \caption{Latency of reading data from Arduino using read-bulk}
  \label{fig:mass_storage_latency_naive}
\end{figure}



\subsubsection{Improving results}

To make a better measurement at the latency of the \acrshort{USB} \acrshort{API}, the test has been modified. Instead of the test running multiple times in the guest code, the guest component runs multiple times. Each time, a new \texttt{Store} will be created. This will let the memory allocation behave similar to the native program.

Figure \ref{fig:mass_storage_latency_optimized} shows a boxplot with the new measurements. The measurements of the native program are the same as in Figure \ref{fig:mass_storage_latency_naive}. The average \acrshort{WASI} program execution time is 4,2\% slower than the average native program, and the median 4,3\% slower. The \acrshort{WASI} program also has more outliers, indicating that the performance of the \acrshort{WASI} program may be less consistent.

Based on these results, we can conclude that running the code using the \acrshort{WASI} \acrshort{USB} \acrshort{API} introduces a small amount of overhead.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{images/mass_storage_1000_runs_optimized.png}
  \caption{Latency of reading data from Arduino using read-bulk}
  \label{fig:mass_storage_latency_optimized}
\end{figure}

\subsection{Memory Usage}
 
 
 ;