\chapter{Architecture}

This chapter presents a summary of how the \acrshort{WASI} \acrshort{USB} \acrshort{API} works under the hood.
Figure \ref{image:api_areas} shows how a program using the API would look like.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
	[mynode/.style = {rectangle, draw, align=center, 
			inner xsep=6mm, inner ysep=3mm},
	-latex,     
	]

	% nodes
	\node[mynode] (inner) {Guest (Wasm Module)};
	\node[mynode,  left=15mm of inner.west] (wasiusb) {WASI USB};
	\node[label={}, above=10mm of inner.west] (title) {Wasm Runtime};

	\node[fit={(inner) (wasiusb) (title)}, draw] (outer) {};
	
	\node[mynode, below=10mm of wasiusb.south] (libusb) {LibUSB};
	\node[mynode, right=10mm of libusb.east] (nativeusb) {Operating System USB API};

	% connections
	\draw [<->, very thick] (wasiusb.east) to node[midway, above] {WIT} (inner.west);
	\draw [<->, very thick] (wasiusb.south) to (libusb.north);
	\draw [<->, very thick] (libusb.east) to (nativeusb.west);
\end{tikzpicture}
\caption{Internals of the WASI USB API. The arrows represent communication between the different areas.}
\label{image:api_areas}
\end{figure}

\paragraph{Guest} This is a Wasm module that is created by a user of the API. It contains code that utilizes the API to communicate with devices. The guest module is sandboxed in the Wasm runtime, meaning that it cannot access any system resources. By utilizing the WASI APIs, such as the WASI USB API, it can get access to system resources. It can communicate with the runtime implementation through the \acrshort{WIT} interface.

\paragraph{WASI USB} This is the host implementation of the WASI USB API. It acts as a bridge between native USB APIs and Wasm modules. This piece is part of the Wasm Runtime, but is not sandboxed, so it can access system resources. To do this, the code is not compiled to Wasm but is instead part of the native runtime binary. This code is platform-dependent and must ensure the exposed API works as similar as possible on each supported platform.

\paragraph{LibUSB} To help the WASI USB runtime implementation having similar behavior on different platforms, LibUSB is used. LibUSB is a lightweight wrapper around native USB APIs, but abstracts them to a universal interface. By using LibUSB, the runtime implementation can be written against the LibUSB API instead of the need to provide separate implementations for each platform.

\paragraph{Operating System USB API} Finally, LibUSB will call the native LibUSB APIs. These are provided by the Operating System kernel.

% \section{\acrfull{WIT}}
% The WIT file provides the definition of the interface between the WASI USB API and a WASM module. Languages with support for the component model provide a way to generate bindings based on the WIT interface. These bindings are used to interact in a natural way with the WIT interface.
% 
% The WASI USB API exposes a WIT interface which guest modules can use to communicate with it. This section will highlight and explain the most important parts of the WIT interface.
% 
% An important note is that in this chapter, `WIT interface' and `interface' will both be used, but have a different meaning.
% WIT interface refers to the whole WIT file.
% A WIT file itself also contains interfaces, which are also discussed here as interfaces. An interface can be thought of as an instance in the WebAssembly Component Model, for example a unit of functionality imported from the host or implemented by a component for consumption on a host. All functions and types belong to an interface. \footnote{https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md\#wit-interfaces}
% 
% \paragraph{World}
% 
% Each WIT interface contains one or multiple worlds. A world describes the collection of imports and exports of a component using the world. A world can import and export functions and interfaces. A world can also be a combination of multiple worlds. This is not used in the USB interface, so it won't be covered further.

% The \texttt{imports} world in code snippet \ref{code:world} is the main entrypoint of the interface. It imports 3 subsections of the interface: \texttt{types}, \texttt{descriptors} and \texttt{usb}. These are separate files with different parts of the WIT interface. The world imports them so they are included in the WIT interface.\\
% 
% \begin{code}
% \inputminted{yaml}{wit/world.wit}
% \caption{USB World}
% \label{code:world}
% \end{code}

% \section{WIT creation}
% The WIT file provides the definition of the interface between the WASI USB API and a WASM module. Languages with support for the component model provide a way to generate bindings based on the WIT interface. These bindings are used to interact in a natural way with the WIT interface.
% 
% In this section, the current USB WIT interface is shown and explained.
% 
% Sidenote: in this chapter, WIT interface and interface will both be used, but have a different meaning.
% WIT interface refers to the whole WIT file.
% A WIT file itself also contains interfaces, which are also discussed here as interfaces. An interface can be thought of as an instance in the WebAssembly Component Model, for example a unit of functionality imported from the host or implemented by a component for consumption on a host. All functions and types belong to an interface. \footnote{https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md\#wit-interfaces}
% 
% \inputminted{yaml}{wit/world.wit}
% 
% the world \texttt{imports} is the main entrypoint of the interface. It imports 3 subsections of the interface: \texttt{types}, \texttt{descriptors} and \texttt{usb}. These are separate files with different parts of the interface. The world imports them so they are included in the interface.
% 
% \inputminted{yaml}{wit/types.wit}
% 
% The \texttt{types} interface provides all the data structures used in the WIT interface.
% 
% \paragraph{device-handle-error}
% An enum containing all the possible error values that could occur when using the USB API.
% 
% \paragraph{direction}
% An enum representing a direction. This is used to represent the direction bit (in bEndpointAddress) in endpoint descriptors.
% 
% \paragraph{usage-type}
% An enum representing various usage types. This is used to represent the usage type bit (in bmAttributes) in endpoint descriptors.
% 
% \paragraph{sync-type}
% An enum representing various sync types. This is used to represent the synchronisation type bit (in bmAttributes) in endpoint descriptors.
% 
% \paragraph{transfer-type}
% An enum representing the four transfer types. This is used to represent the transfer type bit (in bmAttributes) in endpoint descriptors.
% 
% \paragraph{version}
% This struct is used to represent the device-version (bcdDevice) and usb-version (bcdUSB) fields in the device descriptor.
% 
% \inputminted{yaml}{wit/descriptors.wit}
% 
% the \texttt{descriptors} interface contains records for each descriptor kind in the descriptor tree (Figure \ref{fig:descriptor_tree}).
% 
% \inputminted{yaml}{wit/device.wit}
% 
% \section{Runtime implementation}
% The runtime implementation contains the code to create the API. This code runs natively and is therefore system-dependent and not portable. However, this implementation uses LibUSB, which makes supporting all relevant desktop operating systems effortless.

