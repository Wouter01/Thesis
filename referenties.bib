@misc{LibUSB, url={https://libusb.info/}, journal={LibUSB}, title={LibUSB}} 

@misc{WebUSB, url={https://wicg.github.io/webusb/}, journal={WebUSB API}, year={2023}, month={Nov}, title={WebUSB}}

@misc{USB_in_a_NutShell, url={https://www.beyondlogic.org/usbnutshell/usb1.shtml}, journal={USB in a NutShell}, title={USB in a NutShell}}  

@Article{overview_of_webassembly,
AUTHOR = {Ray, Partha Pratim},
TITLE = {An Overview of WebAssembly for IoT: Background, Tools, State-of-the-Art, Challenges, and Future Directions},
JOURNAL = {Future Internet},
VOLUME = {15},
YEAR = {2023},
NUMBER = {8},
ARTICLE-NUMBER = {275},
URL = {https://www.mdpi.com/1999-5903/15/8/275},
ISSN = {1999-5903},
ABSTRACT = {This paper explores the relationship between two emerging technologies, WebAssembly (Wasm) and the Internet of Things (IoT). It examines the complementary roles of these technologies and their impact on modern web applications. First, it delves into the capabilities of Wasm as a high-performance binary format that allows developers to leverage low-level languages for computationally intensive tasks. Second, it seeks to explain why integration of IoT and Wasm is important. Third, it discusses the strengths and limitations of various tools and tool chains that are crucial for Wasm development and implementation, with a special focus on IoT. Fourth, it presents the state-of-the-art with regard to advances that combine both technologies. Fifth, it discusses key challenges and provides future directions. Lastly, it provides an in-depth elaboration of the future aspects of Wasm, with a strong focus on IoT, concluding that IoT and Wasm can provide developers with a versatile toolkit that enables them to balance productivity and performance in both web and non-web development scenarios. The collaborative use of these technologies opens up new possibilities for pushing the boundaries of web application development in terms of interactivity, security, portability, scalability, and efficient computational capabilities. As web and non-web embeddings continue to evolve, the integration of IoT and Wasm will play a crucial role in shaping the future of innovative application development. The key findings of this extensive review work suggest that existing tool sets can be easily conglomerated together to form a new era in WebAssembly–IoT infrastructure for low-power, energy-efficient, and secure edge–IoT ecosystems with near-native execution speed. Furthermore, the expansion of edge–IoT ecosystems can be augmented with prospective cloud-side deployments. However, there remains a strong need to more cohesively advance the amalgamation of Wasm and IoT technologies in the near future.},
DOI = {10.3390/fi15080275}
}

@article{bringing_the_web_up_to_speed,
author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
title = {Bringing the web up to speed with WebAssembly},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062363},
doi = {10.1145/3140587.3062363},
abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.  Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {185–200},
numpages = {16},
keywords = {assembly languages, just-in-time compilers, programming languages, type systems, virtual machines}
}

@misc{docker_without_containers, url={https://wasmlabs.dev/articles/docker-without-containers/}, journal={WebAssembly: Docker without containers!}, author={Alexandrov, Asen and About the authors    
Asen Alexandrov
Staff Engineer at OCTO        Daniel Lopez
Sr. Director at OCTO and OCTO, Asen Alexandrov
Staff Engineer at and OCTO, Daniel Lopez
Sr. Director at}} 

@unknown{wasm_vulnerabilities,
author = {Brito, Tiago and Lopes, Pedro and Santos, Nuno and Santos, José},
year = {2022},
month = {04},
pages = {},
title = {Wasmati: An Efficient Static Vulnerability Scanner for WebAssembly}
}

@article{stack_vs_register_machine,
author = {Shi, Yunhe and Casey, Kevin and Ertl, M. Anton and Gregg, David},
title = {Virtual machine showdown: Stack versus registers},
year = {2008},
issue_date = {January 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {4},
issn = {1544-3566},
url = {https://doi.org/10.1145/1328195.1328197},
doi = {10.1145/1328195.1328197},
abstract = {Virtual machines (VMs) enable the distribution of programs in an architecture-neutral format, which can easily be interpreted or compiled. A long-running question in the design of VMs is whether a stack architecture or register architecture can be implemented more efficiently with an interpreter. We extend existing work on comparing virtual stack and virtual register architectures in three ways. First, our translation from stack to register code and optimization are much more sophisticated. The result is that we eliminate an average of more than 46\% of executed VM instructions, with the bytecode size of the register machine being only 26\% larger than that of the corresponding stack one. Second, we present a fully functional virtual-register implementation of the Java virtual machine (JVM), which supports Intel, AMD64, PowerPC and Alpha processors. This register VM supports inline-threaded, direct-threaded, token-threaded, and switch dispatch. Third, we present experimental results on a range of additional optimizations such as register allocation and elimination of redundant heap loads. On the AMD64 architecture the register machine using switch dispatch achieves an average speedup of 1.48 over the corresponding stack machine. Even using the more efficient inline-threaded dispatch, the register VM achieves a speedup of 1.15 over the equivalent stack-based VM.},
journal = {ACM Trans. Archit. Code Optim.},
month = {jan},
articleno = {2},
numpages = {36},
keywords = {Interpreter, register architecture, stack architecture, virtual machine}
}

@misc{stadia_bluetooth_mode, url={https://stadia.google.com/controller/}, journal={Google}, publisher={Google}} 

@misc{stadia_bluetooth_mode_explanation, title={Reverse-engineering the Stadia Controller Bluetooth switching procedure}, url={https://hackaday.com/2023/12/19/reverse-engineering-the-stadia-controller-bluetooth-switching-procedure/}, journal={Hackaday}, author={Posch, Maya}, year={2023}, month={Dec}} 

@misc{wit_example, title={world.wit at bytecodealliance/wit-bindgen}, url={https://github.com/bytecodealliance/wit-bindgen/blob/main/tests/runtime/resource_aggregates/world.wit}, journal={GitHub}, author={Bytecodealliance}} 

@misc{haskell_existential, title={Existential Types}, url={https://wiki.haskell.org/Existential_type}, journal={Existential type - HaskellWiki}} 

@misc{path_to_components, title={The Path to Components}, author={Luke Wagner}, url={https://www.youtube.com/watch?v=phodPLY8zNE}, journal={YouTube}, publisher={YouTube}, year={2022}, month={Oct}} 

@misc{wasi_usb, title={WebAssembly/Wasi-USB}, url={https://github.com/WebAssembly/wasi-usb}, journal={GitHub}, author={WebAssembly}} 

@misc{wasmtime_website,
	title = {Wasmtime},
	url = {https://wasmtime.dev/},
}

 @misc{tokio, title={Tokio}, url={https://tokio.rs/}, journal={An asynchronous Rust runtime} }
 
 @misc{wasmtime_async_config, url={https://docs.rs/wasmtime/20.0.2/wasmtime/struct.Config.html#method.async_support}, journal={Rust} }

 @misc{wasi_issue_570, title={Proposal: WASI USB API · Issue \#570 · WebAssembly/WASI}, url={https://github.com/WebAssembly/WASI/issues/570}, journal={GitHub}, author={Wouter Hennen} }

 @misc{wasi_meeting_notes, title={meetings/wasi/2024/WASI-04-18.md at main · WebAssembly/meetings}, url={https://github.com/WebAssembly/meetings/blob/main/wasi/2024/WASI-04-18.md}, journal={GitHub}, author={Bailey Hayes} }
 
 @misc{libusb_docs, title={LibUSB docs}, url={https://libusb.sourceforge.io/api-1.0/group__libusb__dev.html} }

 @misc{wasi_security, title={Filesystem Access Security}, url={https://docs.wasmtime.dev/security.html#filesystem-access}, journal={Wasmtime} }
 
 @misc{webusb_security, title={WebUSB API}, url={https://wicg.github.io/webusb/#abusing-a-device}, journal={W3C}, author={Grant, Reilly and Rockot, Ken and Ruiz-Henríquez, Ovidio} }

 @misc{wasmtime_component_bindgen, title={wasmtime::component::bindgen}, url={https://docs.wasmtime.dev/api/wasmtime/component/macro.bindgen.html}, journal={Rust} }

 @misc{wasmtime_store, title={wasmtime::Store}, url={https://docs.rs/wasmtime/20.0.2/wasmtime/struct.Store.html}, journal={Rust} }

 @misc{libusb_hotplug_support, title={windows: hotplug implementation by sonatique · Pull Request \#1406 · libusb/libusb}, url={https://github.com/libusb/libusb/pull/1406}, journal={GitHub}, author={libusb} }

 @misc{libusb_windows_limitations, title={Windows}, url={https://github.com/libusb/libusb/wiki/Windows#known-restrictions}, journal={GitHub}, author={libusb} }

 @misc{libusb_macos_limitations, title={FAQ}, url={https://github.com/libusb/libusb/wiki/FAQ#how-can-i-run-libusb-applications-under-mac-os-x-if-there-is-already-a-kernel-extension-installed-for-the-device-and-claim-exclusive-access}, journal={GitHub}, author={libusb} }
 
 @misc{cargo_component, title={GitHub - bytecodealliance/cargo-component: A Cargo subcommand for creating WebAssembly components based on the component model proposal.}, url={https://github.com/bytecodealliance/cargo-component?tab=readme-ov-file}, journal={GitHub}, author={bytecodealliance} }
 
 @misc{memory_pool_wikipedia, title={Memory pool}, url={https://en.wikipedia.org/wiki/Memory_pool}, journal={Wikipedia}, author={Contributors to Wikimedia projects}, year={2023}, month={Aug} }

 @misc{usb_specification_boot, title={Universal Serial Bus Mass Storage Specification For Bootability}, url={https://usb.org/sites/default/files/usb_msc_boot_1.0.pdf}, journal={USB-IF}, publisher={USB-IF}, author={USB-IF}, year={2004}, month={Oct} }
 
 @misc{usb_specification_bulk, title={Universal Serial Bus Mass Storage Class, Bulk-Only Transport}, url={https://www.usb.org/sites/default/files/usbmassbulk_10.pdf}, journal={USB-IF}, publisher={USB-IF}, author={USB-IF}, year={1999}, month={Sep} }
 
 @misc{mbrman, title={mbrman package, Rust}, url={https://docs.rs/mbrman/latest/mbrman/}, journal={Rust} }
 
 @misc{exfat_package, title={exfat package, Rust}, url={https://docs.rs/exfat/latest/exfat/}, journal={Rust} }

 @misc{rusb, title={Rusb}, url={https://docs.rs/rusb/latest/rusb/}, journal={Rust} }
 
 @misc{memory_model, title={Why the Component Model?}, url={https://component-model.bytecodealliance.org/design/why-component-model.html}, journal={The WebAssembly Component Model} }

 @misc{wasmkit, title={WasmKit}, url={https://github.com/swiftwasm/WasmKit}, journal={GitHub} }
 
 @misc{wasmer, title={Wasmer}, url={https://wasmer.io/}, journal={Wasmer} }

 @misc{rust_lang, title={Rust}, url={https://www.rust-lang.org/} }

 @misc{wasi_roadmap, title={WebAssembly: An Updated Roadmap for Developers}, url={https://bytecodealliance.org/articles/webassembly-the-updated-roadmap-for-developers}, journal={Bytecode Alliance}, author={Hayes, Bailey}, year={2023}, month={Jul} }

 @misc{proposal_phases, title={WASI: Proposals}, url={https://github.com/WebAssembly/WASI/blob/main/Proposals.md}, journal={GitHub}, author={WebAssembly} }

 @misc{wasi_milestones, title={WASI 0.2 Launched}, url={https://bytecodealliance.org/articles/WASI-0.2}, journal={Bytecode Alliance}, author={Gohman, Dan}, year={2024}, month={Jan} }

 @misc{canonical_abi, title={Canonical ABI}, url={https://component-model.bytecodealliance.org/advanced/canonical-abi.html}, journal={The WebAssembly Component Model} }

 @misc{usb_wasi_impl, title={Wouter01/USB\_WASI}, url={https://github.com/Wouter01/USB_WASI}, journal={GitHub}, author={Wouter01} }
 
 @misc{wit_examples, title={The Component Model Docs}, url={https://github.com/bytecodealliance/component-docs/blob/74beecf57c9012f6db48ba4f9b18865a4f2798c6/component-model/src/design/wit.md}, journal={GitHub}, author={bytecodealliance} }

@article{wasi_iot,
 author = {Ray, Partha},
 year = {2023},
 month = {08},
 pages = {275},
 title = {An Overview of WebAssembly for IoT: Background, Tools, State-of-the-Art, Challenges, and Future Directions},
 volume = {15},
 journal = {Future Internet},
 doi = {10.3390/fi15080275}
 }
